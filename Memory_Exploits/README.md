# 内存利用

## 内存破坏

* 无边界的数据复制是错误的。


* 一些API:
	- strcpy()
	- strcat()
	- sprintf()
	- gets()

#### strcpy

* 内存破坏的基本例子：

```
int vul_fc(char *userstring)
{
    char buf[128];
    strcpy(buf, userstring);
    /*..*/
}
```

#### strncp and NULL byte

* 更好的API可能没有被正确的使用，比如**strncpy()**，它用来限制长度的参数没有被理解：

```
int vuln_function(char *userstring)
{
	char buf[128];
	strncp(buf, usertring, strlen(userstring));
	/*..*/
}
```

* 如果设置的长度不包括NULL字符串结束符：要复制的数据大于或等于buf的大小，则buf里不会放置NULL结束符：

```
int vuln_function(char *userstring)
{
	char buf[128];
	strncp(buf, usertring, sizeof(buf));
	/*..*/
}
```

* 正确的写法应该是：**sizeof(buf)-1**.

* C字符串函数需要通过一个NULL字符来知道字符串什么时候结束。在后面的代码中，它将假设字符串的长度只有sizeof(buf)，但实际上它一直到内存中的下一个NULL字节。

* 这可能是攻击者控制的相邻内存块，比如堆栈上声明的另一个缓冲区。

#### strncat

* 比如字符串拼接函数**strcat()**。这个函数将源缓冲区的目标附加到目的缓冲区，添加到目的缓冲区中现有的C字符串结尾。

* 大小限制参数不包括目的缓冲区中现有的字符串：

```
int vuln_function(char *string)
{
	char buf1[256];
	strncat(buf1, "static data", sizeof(buf1) - 1);
	/*..*/
	strncat(buf1, string, sizeof(buf1)-1);
}
```

* 如果buf1中已经有数据，那么会重写buf1！

#### 宽字符

* 对于宽字符有很多误解，比如*wchar_t*。

* 在win32中，wchar_t是16位(UTF-16编码单元). 在Linux中，wchar-t是32位(UTF-32)。

* 字符串长度计算错误可以由sizeof返回对8位字符的计数而宽字符大于8位引起：

```
int vul_funcion(char *string1)
{
	wchar_t buf1[256];
	mbstowcs(buf1, string1, sizeof(buf1)-1);
}
```

* 字符串长度由sizeof()给出，但的大小参数是要写入的宽字符数。宽字符的位数大于8位字节位数：

```
wchar_t buf1[256];
mbstowcs(buf1, string1, sizeof(buf1)-1);
```

* 在Windows中，wchar_t是16位的，sizeof(buf)等于512。在这样的模式中，511位的宽字符将被复制到目标缓冲区，而目标缓冲区本来是255位。

----

## 数据类型的有/无符号

* 源数据类型(32位)：
	- signed char/unsigned char
	- signed short/unsigned short
	- signed int/unsigned int

* 用于大小计算的重新定义：
	- size_t (unsigned)
	- size_t (signed)


* 默认情况下，除非特别声明，所有数据类型都是有符号的。
* 许多接收大小参数的函数读入无符号的值。


* 字符y=-1和字符x=255在二进制法表示中是一样的

* 无符号类型的大值（最高位为1）是有符号类型的负值。

* 函数**read()**只接收无符号值作为长度。所以如果这个值是负的，经过一个if比较，它就会溢出。

* 例如，如果长度是**-1**（即0xFFFFFFF），当执行长度检查时，它比较-1是否小于MAXNUMBER。然后，长度被传递给读入，被转换为无符号中等价的-1(对于32位是42949672965)。



---
## 整数溢出
*  整数超过数据类型限定的大小就会导致**环绕**。在下面的例子中，x会变为0：

```
x = 255;
x += 1;
```

* 指针溢出：指针是无符号整数：

```
int StrStuff(int sock, char *buf, size_t buflen)
{
	size_t dataSize;
	char *maxpoint = buf + buflen;
	dataSize = readDataSize(sock);
	if (buf + dataSize < maxpoint)
	{
		read(sock, buf, dataSize);
		return 0;
	}
return 1;
}
```

### 整数溢出的利用

* 在下面的代码中，buf有着足够的空间并多一位来存储字符串中的NULL。
* 如果提供的数据是0xFFFFFFF (最大的32位值)，当加上1，它将变回0。这意味着malloc读入的长度是0字节。
* malloc()会返回一个大小不足的缓冲区，并使得read()中内存泄露。

```
int getData(int sock)
{
	unsigned int len;
	char *buf = NULL;
	len = getDataLen(sock);
	buf = malloc(len + 1);
	read(sock, buf, len);
	buf[len+1] = 0x0;
}

```

------------------

## 元字符注入

* 在shell中，引号和分号是元字符。

* 比如，如果输入中含有**;**，解压输入的文件的命令将会变成两个可执行的命令。

```
void extractUserZip(char *userFile)
{
	char command[1024];
	snprintf(command, 1023, "unzip %s", userFile);
	system(command);
	return;
}

```


----


## 提示

* grep中的malloc()和其他内存分配函数。memory allocation functions.
* 查看计算数值大小的数据类型
* 查看用于长度检查的值：他们有符号吗？
* 如果提供了一个负值会发生什么？
* 寻找eval函数，比如说**system()**



---------------------------

## 文件

### Assembly

- Shell spawn


----
### Buffer Overflows

- Stack overflow examples

----
### Integer Overflows

---
### Tools

---
### C-codes

- Get env variable

----

## 声明
有一些脚本比较旧，有一些不是我写的。如果你认出了一些脚本，请联系我，这样我能assign some credit。
